{"meta":{"title":"PPuyan","subtitle":"","description":"","author":"ppuyan","url":"https://ppuyan.github.io","root":"/"},"posts":[{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：02-着色器基础","date":"2021/01/15","text":"像猫一样编程~ 物体到图像Mesh renderer组件 Unity检查对象的边界框判断物体部分或全部是否在摄像机视锥体内。 Transform 组件 各自负责什么 第一个shader创建Unlit Shader，并以此创建新材质 Shader编译Unity Shader编译器会将代码转换成不同的平台代码。例如D3D、OpenGL等。 可以通过Compiled code查看编译平台和编译后的代码。 Shader结构:1234567891011121314151617181920212223242526Shader “Custom/First Shader” &#123; Properties &#123; ///TODO &#125; SubShader &#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc” struct input &#123; ///TODO &#125; struct v2f &#123; ///TODO &#125; v2f vert (input i ) : SV_POSITION &#123; ///TODO &#125; float4 frag (v2f i ) : SV_TARGET &#123; ///TODO &#125; ENDCG &#125; &#125;&#125; SubShade：可以用于构建不同平台或实现不同的细节程度（LOD） Properties我们可以添加自己定义的变量属性并显示到Unity面板上。此时并没有声明变量，只是出现在了Unity面板上。 一般的变量名以下划线开头。 定义Unity面板上的名字 定义数据类型 赋予初始值 123Properties &#123; _Tint(“main Color”，Color) = (1，1，1，1)&#125; Pass我们在Pass中编写shader代码。 shader 语言目前有三种，HLSL（DirectX）、GLSL（OpenGL）、Cg（NVIDIA和微软协作） Unity Shader是HLSL和Cg语言的变体。 以CGPROGRAM和ENDCG包围代码 12345Pass &#123; CGPROGRAM ///TODO ENDCG&#125; 编译指令#pragma指示哪些程序使用哪些函数。 1234CGPROGRAM #pragma vertex vert //告诉顶点着色器使用vert这个函数 #pragma fragment fragENDCG 引用文件#include一整套完整的shader需要大量的样板代码。定义公用变量，函数和其他内容。类似其他高级语言中的类。 Shader没有类，可以分成多个文件，使用**#include**加载 Unity为我们准备了UnityCG.cginc。 123456CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc”ENDCG 层次结构 声明变量我们要使用Properties中自定义的变量时，我们首先需要声明它。 在Pass中声明 12345678Pass &#123; CGPROGRAM #pragma #include float4 _Tint; …… ENDCG&#125; 顶点着色器和片元着色器 顶点着色器输出处理后的顶点数据 之后进入光栅化阶段，进行三角形处理：以处理的三个顶点之间进行插值计算 传递插值数据到片元着色器 数据的传递和语义渲染东西时，我们要输入一些数据，处理后，再输出一些数据。 输入： 我们将模型的顶点数据输入到vert顶点着色器中 使用语义POSITION，指的就是物体在模型空间下的顶点数据 123void vert (float4 position : POSITION) &#123; ///TODO&#125; 输出： 在前面的vert顶点函数中，我们要返回处理后的顶点坐标。坐标空间是四维的齐次坐标，使用4x4矩阵。 同样的frag片元函数中，我们要输出颜色值。 同时使用SV_POSITION语义来规范输出。 SV指的是Systems Value（系统值） SV_POSITION指的是用于标识经过坐标变换后的顶点坐标。 SV_TARGET指的是片元着色器的颜色输出语义 123456float4 vert (float4 position : POSITION) : SV_POSITION &#123; return 0;&#125;float4 frag (float4 position : POSITION) : SV_TARGET &#123; return position;&#125; 这里我们尝试输出一个物体本地坐标的颜色，因为线性插值的关系，所以会有颜色的过度 通常x方向为红色，y方向为绿色，z方向为蓝色。 1234567891011float4 vert(float4 position:POSITION,out float3 localPotition: TEXCOORD0) : SV_POSITION&#123; localPosition=position.xyz;//模型空间坐标 return mul(UNITY_MATRIX_MVP, position);//顶点坐标的转换&#125;float4 frag (float4 position:SV_POSITION,float3 localPosition : TEXCOORD0):SV_TARGET &#123; return float4 (localPosition,1);&#125; TEXCOORD0语义一般指顶点的第一套纹理坐标 这里并没有使用纹理的意思，使用TEXCOORD0语义，可以就当作占个坑，用这个坑过度一下处理数据这样。 颜色调整颜色的值应该在0~1之间。 而默认的球体半径是0.5的，所以在模型空间中它的值应该是-0.5~0.5 这就导致0以下的数值会被舍弃掉，所以我们把他规范到0~1中 1return float4 (localPosition+0.5, 1); 使用结构体为了代码的整洁，我们可以使用结构体作为输入和输出。 12345678910111213141516Pass &#123; CGPROGRAM …… struct Input &#123; float4 position : POSITION; float3 localPosition : TEXCOORD0; &#125; struct v2f &#123; float4 position : SV_POSITION;//这里直接使用语义就可以省下顶点着色器的输出语义 float3 localPosition : TEXCOORD0; &#125; …… ENDCG&#125; 整合上面的代码 123456789101112131415161718Pass &#123; CGPROGRAM …… v2f vert (Input i ) &#123; v2f o; i.localPosition=o.position.xyz;//模型空间坐标 mul(UNITY_MATRIX_MVP, position);//顶点坐标的转换 return o; &#125; float4 frag (v2f i ) : SV_TARGET &#123; return float4 (i.localPosition,1); &#125; ENDCG&#125; 贴图贴图采用UV二维坐标 左下角（0，0）右上角（1，1） OpenGL由下到上 | D3D由上到下 添加贴图添加Properties 123Properties &#123; _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;&#125; 声明变量 123float4 _Tint;sampler2D _MainTex;float4 _MainTex_ST;//用于Tilling And Offset 数据输入和输出的结构体 12345678struct input &#123; float4 position : POSITION; float2 uv : TEXCOORD0;&#125;struct v2f &#123; float4 position : SV_POSITION; float2 uv : TEXCOORD0;&#125; 在vert函数中我们直接返回uv值 123456v2f vert(input i )&#123; …… mul(UNITY_MATRIX_MVP, position); o.uv=i.uv; ……&#125; 然后在frag函数中用tex2D进行采样 123float4 frag (v2f i ) : SV_TARGET &#123; return tex2D(_MainTex, i.uv);&#125; 发生纹理变形是因为插值在三角形之间是线性的。Unity球体在极点附近只有几个三角形，其中UV坐标变形最大。因此，UV坐标在各个顶点之间非线性地变化，但是在顶点之间，它们的变化是线性的。所以，纹理中的直线突然在三角形边界处改变方向。 平铺和偏移就是使用之前添加的_MainTex_ST 1i.uv = v.uv * _MainTex_ST.xy + _MainTex_ST.zw; 通常我们使用在UnityCG.cginc中定义好的函数进行这个操作 1i.uv = TRANSFORM_TEX(v.uv, _MainTex)； Unity中的图片设置 Wrap Mode： Clamp：图片被限制在0~1之间 Repeat：在超过1之后的地方会进行repeat 言简意赅，图片在Tilling改变后是否会被拉伸。 在0-1范围内，两者在图像边缘的处理上会存在差别 Repeat的时候，如果边缘两处颜色不相似，边缘处会渗出一点点另一边的颜色。 Clamp的时候边缘并不明显。 Filter Mode： img 主要解决纹素投影到像素不完全匹配的问题。 因为采样的问题，单个像素出现的纹素过多的时候，两个像素间采样的值将会超过一个纹素样本 Point（不过滤）采样的时候取最近的纹素，会产生块状外观 默认为Bilinear（双线性）在两个纹素间的某个位置进行采样，将这两个纹素进行插值。 启用Mipmap，默认是启用的使用不同层级的贴图，例如原贴图512x512那么其mipmap就是256x256,128x128等 使用原理就是，当单个像素内，纹素密度过高的时候，使用较小的mipmap，来降低纹素密度。 有mipmap 无mipmap 各向异性过滤当角度过于平的时候，会出现远处很模糊，这是因为远处纹素密度过大，使用了较低的mipmap所以会很模糊。 在两个维度上缩放不同数量，所以是各向异性。例如除了256x256的mipmap还有256x128、256x64等的mipmap。 无各向异性滤波 有各向异性滤波 这些额外的Mipmap不会像常规的Mipmap预先生成，采样时进行额外的模拟。 不需要额外的空间，但采样成本变高。 参考像猫一样编程~02 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础","permalink":"https://ppuyan.github.io/2021/01/15/note_shader_02.shader-fundamentals/","photos":[]},{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：01-渲染管线","date":"2021/01/15","text":"简单的概述渲染管线~ GPU or CPU？刷新率（fps）会影响游戏体验。正常30Hz；流畅60Hz；VR双目常态90Hz； 以iPhone Xs Max来说，一个游戏如果要达到每秒30帧，需要多少计算呢？数量级能达到十亿、百亿。（[分辨率] 2688 * 1242 * [帧率] 30 * [填充率（平均最小3）] n * [单像素计算步骤数] m） CPU善于处理单一复杂运算，GPU处理较大的数量级运算（并行计算，速度更快） GPU原理GPU发展趋势：可配置固定管线 \\rightarrow 可自定义算法的编程模块 GPU硬件结构 数据并行结构GPU是流处理器，内有成千上万小型处理器——shader运算核。 同时处理大量相似数据 相互独立不用访问相邻核心 少了很多用于逻辑运算和缓存 SIMD（单指令多数据） 访问数据的延迟远远大于运算的延迟，采用分离运算和数据的设计减少延迟。 即先按顺序完成所有像素的运算指令，再返回去执行访问指令。 单指令多数据 每个像素的shader调用被称为一个线程，与CPU线程不同，GPU线程会带有一点输入内存和运行寄存器。使用相同shader的线程可以组合成线程束。 例如英伟达GPU的线程束可包含32个线程，那要计算2000个像素就需要2000 / 32 = 63（向上取整）个线程束。第一个线程束停滞处理问题时，第二个开始运行，以此类推，最后一个线程束停滞时再回到第一个线程束。 渲染管线（流水线） 四个大阶段：应用阶段、几何运算、光栅化、像素运算 应用阶段一般由CPU执行; 包括用户输入处理、碰撞检测、动画、物理模拟、全局加速算法等; 基于CPU，开发者有绝对控制权; 可通过Compute Shader 交给GPU来做，将GPU当做一个高并行的普通处理器来使用; 输出渲染数据到下一阶段：几何元素（点、线、三角面）、纹理、参数等。 几何运算细分为四个子阶段：顶点Shading阶段、投影阶段、剪裁阶段、屏幕映射阶段。 顶点着色器阶段（可直接编程，vertex shader）计算顶点位置，输出法线，纹理坐标等顶点相关信息 可用来处理顶点动画，修改法线方向 模型空间到世界空间，世界空间到相机空间，再投影、剪裁，最后变换为单位立方体 空间变换： Object \\Rightarrow World 模型-世界 World \\Rightarrow Camera 世界-相机 Camera \\Rightarrow clip 相机-裁剪（投影变换） Tangent \\Rightarrow World （法线贴图） World \\Rightarrow Tangent（视差贴图） 投影后，模型所在空间为裁剪空间。 三维空间 \\Rightarrow 另一个三维空间 Z坐标存在Z-buff中 最终模型从三维投影到二维平面。 顶点着色阶段前也有一些数据操作，在DirectX中称为输入整合器，将流数据编为集合传入管线。其可以根据顶点和颜色数组生成物体三角面。 GPU instancing是通过输入整合器实现的。允许一个物体通过变化数据完成多次绘制，但只占用一个Draw Call。 可选顶点过程部分GPU支持此阶段：细分曲面，几何着色和流输出。 细分曲面：原有几何体上增加顶点和三角面。对比CPU，GPU增加顶点的开销不大。 几何着色：也能产生新顶点和三角面，但不一定要在原有图素上。可用于粒子的生成、草原、毛发等。 流输出：将GPU当几何处理器，处理后的信息存在数组，后续交由CPU或GPU操作。 裁剪部分在视觉空间里的图素需要裁剪。 裁剪阶段使用四维齐次坐标。因为透视投影后，三角面无法使用线性插值，第四个数值的作用就是为了能正常插值。（透视修正插值） 屏幕映射裁剪后以三维坐标传入，称为窗口坐标。 窗口坐标缩放到屏幕像素，称为屏幕坐标，z值映射到0~1 光栅化三角面输入，找到三角面内所有像素。 子阶段：三角面设置，三角面遍历 三角面设置阶段：会计算三角面的微分方程、边的等式和其他数据，这些数据用于三角形遍历以及一些几何阶段产生的Shading数据的插值。 三角形遍历：会判断三角形与像素（采样点）的交叠并生产片元，片元内包含了三个顶点间的插值数据（包含深度）。 像素运算此阶段逐像素操作，每个图素内的像素（而不是屏幕内的像素）都会使用一段程序来确定是否可见（如深度测试）和其颜色。 子阶段：像素Shading，合并阶段 像素/片元着色器（可编程，fragment shader）输入：插值后的Shading数据， 输出到合并阶段：一种或多种颜色。 片元：三角面全部或部分覆盖单个像素的部分。 此阶段可以丢弃一些片元 合并阶段混合颜色缓冲 z-buff（深度缓冲）à决定可见性。渲染图素时，同一像素内，z值与z缓冲值比较，z值更小会被渲染，更新z缓冲和颜色缓冲；z值更大则无变化。 传统z-buff缺点：只存储一个深度，无法用于半透明。半透明后于不透明物体绘制。 early-z/pre-z：在像素shading前进行深度测试。但是像素阶段可以改变深度或者抛弃片元（Alpha Cutoff），这会导致Early-Z失效。 模板缓冲：用于记录一些图素的位置，图素可以用多种方式写入模板缓冲，此缓冲可用于控制是否写入颜色缓冲与深度缓冲。用这样的方法我们能实现一些有趣的效果，例如只有通过特殊镜片才能看到的文字等等。 模板测试实现非欧几何 最后合并颜色，当前图素颜色与缓冲颜色进行合并，半透或叠加。 参考https://zhuanlan.zhihu.com/p/336999443 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础","permalink":"https://ppuyan.github.io/2021/01/15/note_shader_01.render-pipline/","photos":[]},{"tags":[{"name":"Substance Painter","slug":"Substance-Painter","permalink":"https://ppuyan.github.io/tags/Substance-Painter/"}],"title":"Substance Painter入门教程笔记：煤油灯","date":"2020/12/10","text":"初次接触Substance Painter！ 前言​ 初次接触Substance Painter，主要为了熟悉SP界面和工作流程。本文并非教程，只是记录学习轨迹，所以开门见山地贴出教程地址，有兴趣可以前往学习。 教程地址： 官网：SUBSTANCE PAINTER 2018 初学者B站：Substance Painter 入门教程：煤油灯 正文快捷键视图旋转：alt+左键 视图缩放：alt+右键 视图平移：alt+中键 旋转环境光贴图：shift+右键 在模型上选择Texture set（材质）：ctrl+alt+右键 循环贴图显示模式：shift+B 返回材质模式：M 循环通道显示：C 笔刷大小：ctrl+右键左右移动 笔刷alpha硬度值：ctrl+右键上下移动 笔刷流量：ctrl+左键左右移动 阻止画刷叠加构建：A 旋转笔刷alpha贴图：ctrl+左键上下移动 画直线：左键+shift 直线按15°刻度吸附：shift+ctrl+左键 Stencil模板：s+右键缩放，s+左键旋转，s+中键移动 笔刷黑白切换：x 要点Texture set = material ID在SP中Texture set（纹理设置）是三维软件中设置的Material ID（材质ID） Texture set=Material ID 导入外部贴图Shelf -&gt; importing resources 为导入的资源创建关键字或标签。 图层文件夹和智能材质使用图层文件夹方便管理材质。 右键这个文件夹可以创建智能材质，创建智能材质会自动存储烘焙好的贴图，方便下次使用的时候自动设置。 同样的也可以创建智能遮罩。 图层覆盖上面图层覆盖下面图层的效果，比如Height 在第一个层中Height值为0，但是下面的图层中存在高度值，并仍然显示。 切换图层中的显示模式BaseColor为Height模式，可以看到默认的混合模式为线性添加，意味这所以图层高度值是叠加的。 如果要当前图层覆盖下面所有图层，将混合模式设置为normal标准 流程创建透明材质创建新shader并增加不透明度（opacity） PS：2020新版SP创建shader被放置在纹理设置里 设置Shader：pbr-metal-rough-with-alpha-blending 新建填充层，并设置透明度（右键视图窗口快捷调出属性面板） 烘焙贴图选择Texture set list里的base1打开纹理设置进行烘焙 教程中直接使用高模制作贴图，所以不用烘焙法线贴图和厚度贴图。在ID选项中把Color Source的Vertex Color改为Material Color。（新版默认是材质颜色）在高模选项中选择lantern_id,为了烘焙ID贴图，教程中弄了一个一样的模型，但是在模型的不同材质间赋予了不同颜色。 重新烘焙ID贴图烘焙的时候造成投射错误，会让后续使用ID贴图制作mask的时候存在错误。所以应该在烘焙的时候炸开（分离）模型。 在烘焙设置的Match选择中选择by mesh name，在下面的选项中更改高低模型对应的后缀，例如教程里的_id、_main。通过组名称来分离模型，SP在计算光线追踪的时候就会单独计算名字相匹配的模型。 创建基础材质颜色基础层选择Texture set list=&gt;base1 新建图层base调节颜色 粗糙度层新建图层rough并添加黑色遮罩，关闭除rough以外的通道 在遮罩下添加Generator生成器dirt（根据之前烘焙的贴图程序化的生成污渍mask） 解决UV接缝，打开生成器里的Triplannar（三面投射）*后续使用到新的图层或填充也要开启三面投射* 在rough-&gt;mask下再新建一层并填充特效（图层-添加特效-添加填充）。在Grayscale添加Grunge Paint Scratch灰度图 改变Grunge Paint Scratch混合模式为Lighten（max） 实现效果： 油迹斑点层新建图层paint specks并添加黑色遮罩，关闭除height以外的通道，设置Height值为正数。 与rough类似，在mask上添加填充特效。 同样的为了避免UV接缝，打开三面投射。 在mask的填充中添加灰度图BnW Spots 1，适当调节参数 实现效果： 边缘暗淡新建图层，添加黑色遮罩，添加Mask Editor生成器，调节curvature曲率的参数 在mask上再添加新的填充特效。使用Grunge Rust Fine灰度图。并改变混合模式为Multip 实现效果：可以看到边缘有一些暗淡和无序的脏迹的效果。 再做一层变化复制上一层图层。更换新的填充特效。使用Grunge concrete old灰度图。调节层的颜色，复制多一层是为了使用不同的颜色，增加细微变化。 改变整个图层的混合模式为Overlay叠加，并降低透明度 实现效果： 第三层颜色变化添加黑色遮罩，添加填充特效，添加Light生成器。 添加一层填充特效，通过脏迹图来调节light生成器。添加Grunge concrete old灰度图，改变混合模式为Multiply 适当调节颜色，并更改图层混合模式为Value 添加生成器Dirt，借助生成器Dirt让高光颜色更集中。改变混合模式为Multiply 实现效果： 铁锈材质创建新图层base打开color，height，rough，ao通道。默认没有ao通道需要通过texture set设置面板里面添加。为各自通道添加导入的rust贴图。调节高度值 为材质创建遮罩创建图层文件夹，把上面的base图层放入其中。右键文件夹创建黑色遮罩层。 创建填充特效，选择Grunge 004作为灰度图 在这里我们不使用三面投射的方式，因为这个方式会出现一些映射模糊，直接使用UV投射。 创建填充特效，选择Grunge concrete old作为灰度图，设置三面映射。更改混合模式为Lighten（max） 创建Light生成器（分离铁锈积聚的地方）改变混合模式为Multiply，只在斜面上出现铁锈。 创建Dirt生成器，混合模式为Lighten（max） 创建Mask Editor生成器，主要为了把铁锈集中在边缘。 为Mask Editor增加第一张贴图：Grunge concrete old灰度图控制，并使用Multiply混合模式。 增加第二张贴图：Grunge scratch rough，并使用Lighten（max）混合模式，这张贴图主要增加划痕效果 最后把Mask Editor改为Lighten（max）混合模式 最后效果： 为铁锈颜色添加滤镜主要是更改铁锈颜色 智能材质的应用和图层链接智能材质可以直接拖拽到新的Texture set上，会自动设置对应烘焙好的贴图。更新其中一个Texture set的设置，另一个不会跟着变化。 图层链接 笔刷系统笔刷大小，笔刷流量，笔刷透明度，笔刷抖动，shelf中的笔刷预设，延迟笔刷，路径笔刷 保存笔刷预设：在绘画模式下属性面板中右键可以保存预设 tool工具预设会同时保存笔刷和材质 material材质预设只会保存材质 brush笔刷预设只会保存笔刷 绘画校准 分别是：镜头|wrap包裹|平面下的效果 在UV模式下不会画出uv边界，都适用于3d/2d窗口 Stencil模板：可以绘制图案。 纹理映射模式类似上面的stencil，不同在于有完整的材质属性，可以跨多个通道进行映射而不是一个灰色通道。 类似stencil的快捷键，同样使用s+鼠标键进行操作。使用的时候新建绘画图层，切换到映射模式，设置好需要映射的贴图即可开始绘制。 可以在显示设置里设置模板透明度。绘制的贴图颜色同样可以在层里面添加HSL滤镜进行调色 克隆工具特使的混合模式，要使用克隆工具要先新建绘画图层，并且把需要进行克隆的通道图层混合模式设置成passthrough穿过，例如basecolor，height，ao等通道信息都设置成passthrough穿过 克隆模式是非破坏性的，更改克隆图层下面的图层属性后，克隆的东西也会随着更新，就是passthrough模式的作用 克隆类似PS里面的印章。按住V键设置克隆源，就可以开始绘制。 锚定点系统文字细节更改笔刷的alpha贴图就可以印刷文字。 增加文字的AO，通过增加滤镜HBAO达到效果。 为文字增加铁锈影响使用锚定点。锚定点可以用来链接图层堆叠里的其中一个数据到另一个地方。 为我们上面的文字图层增加锚定点。右键-&gt;添加锚定点 打开rust-&gt;mg_dirt下面的MicroHeight选择anchor points指定刚刚文字图层里面的锚定点。设置引用通道为Height 然后进入微细节调节数值。 金属材质创建新的填充图层，使AO，高度信息覆盖下面图层。 设置金属值为1 添加Grunge rough dirty为Roughness贴图，设置三面映射。 使用色阶调整roughness贴图： 为图层增加levels特效，选择roughness通道作为受影响通道 边缘遮罩复制上述图层，并调整更亮的颜色，使用遮罩，让这个更亮的颜色集中在边缘位置。 添加黑色遮罩。添加Mask Editor生成器。 为Mask Editor添加纹理Grunge Dirt Scratched，记得把Texture值拉到1，不然会不起作用。 更改上述贴图的混合模式为Max（Lighen） 使用层文件管理金属材质的时候，别忘了要把文件夹的AO和高度信息覆盖下面图层。 使用ID贴图制作遮罩为metal rough这个材质文件夹添加颜色选择遮罩，这里就要使用到上面步骤中烘焙到的ID贴图。 选取ID颜色，指定金属部位。同时为了使金属部分也有铁锈，要把rust材质文件夹移动到最上层。 当初在制作rust材质的时候，没有使用金属通道，会导致铁锈部分看起来会太暗。 从金属通道可以看出来，metal rough占据了整个金属通道，而铁锈部分没有产生作用，这是不对的。我们把rust的金属通道打开，这时显示正确。 灯芯材质选择Texteure set-&gt;glass_enclosure 创建新的填充图层，类似的，我们使用层文件夹的形式创建遮罩。 这里我们使用新的遮罩方式。 为这个文件夹创建黑色遮罩，添加绘图特效。 使用几何填充工具。 在知道模型是分离的情况下可以使用模型填充，或者UV是分离的情况下也可以选择UV填充模式 把这个wick材质的AO，高度信息覆盖下面图层。 为这个base的高度通道，添加Fabric Alternate V贴图。并调整平铺值和UV比例值大小。 添加HBAO滤镜。 为这个base的basecolor通道添加Gradient Linear 1贴图 增加Gradient滤镜。调整灯芯的渐变颜色，适当的可以用使用paint特效，使用笔刷画，增加不规则感。 污垢材质使用同样的方法，选择Texture set-&gt; base1 创建层文件夹，Height和AO通道下设置normal标准混合模式。 创建填充图层，并添加黑色遮罩。 添加dirt生成器 添加填充特效，添加grunge concrete old作为灰度图，设置三面映射，Multiply混合模式 污垢自上而下复制上面的图层，删除填充图层，改变生成器为Mask Editor 这次我们关闭curvature，打开position gradien方位渐变，调节参数，使得污垢自上而下。 为这个生成器添加grunge concrete old贴图，并设置Multiply混合模式，主要为了打散污垢。 调节方位渐变，使得污垢自上往下。 玻璃材质玻璃材质主要是制作Roughness贴图。通过叠加多张sp自带的程序化贴图来使粗糙度有更多的变化。 选择Texture -&gt; glass1 添加新的填充图层命名为Glass关闭除Color，rough，opacity外的通道 填加新的填充图层，添加黑色遮罩 添加填充特效，加入Grunge rough dirty贴图。添加色阶特效 添加填充特效，加入Grunge stains small hollow贴图，Lighten（max）混合模式 添加填充特效，加入Grunge leaks贴图，Multiply混合模式 调整这些贴图的平衡到适合的值。 最后把Glass中的颜色值调接近白色 在渲染前先完善玻璃材质。为上面的玻璃添加之前创建好的dirt智能材质。 渲染进入玻璃的Texture set-&gt;glass1 打开顶部的Iray，进入着色器选项 把折射拖到1 进入显示设置可以调整背景，镜头，后处理等信息。 在上面的Iray设置中可以调整渲染时间，采样率等。 最终渲染效果： 导出贴图SP中有预设好的很多渲染器和引擎的贴图模板配置。当然也可以手动添加模板。","permalink":"https://ppuyan.github.io/2020/12/10/note_sp_start-with-lantern/","photos":[]},{"tags":[],"title":"Test","date":"2020/12/02","text":"Test TestTestTestTestTestTest123&lt;p&gt;code test&lt;/p&gt;&lt;div&gt;code test&lt;/div&gt;&lt;div&gt;long code test-----------------------------------------------------long code test&lt;/div&gt; 展开查看 System.out.println(\"Hello to see U!\");","permalink":"https://ppuyan.github.io/2020/12/02/Test/","photos":[]}],"categories":[],"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"},{"name":"Substance Painter","slug":"Substance-Painter","permalink":"https://ppuyan.github.io/tags/Substance-Painter/"}]}