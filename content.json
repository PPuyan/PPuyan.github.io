{"meta":{"title":"PPuyan","subtitle":"","description":"","author":"ppuyan","url":"https://ppuyan.github.io","root":"/"},"posts":[{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：04-光照模型","date":"2021/01/15","text":"实现经典的光照模型；使用Unity内置PBS函数 法线光照计算是在世界空间下进行的，所以我们需要把物体的法线从模型空间转到世界空间下。 首先我们需要引入模型的法线 1234567struct input&#123; float3 normal ：NORMAL;//用NORMAL语义来获取模型法线&#125;struct v2f&#123; float4 position：SV_POSITION; float3 normal ：TEXCOORD1;&#125; 我们使用矩阵来进行转换。Unity为我们准备了一个变换矩阵float4x4 unity_ObjectToWorld 虽然这是一个四维矩阵，我们只需要前三维进行转换 并且我们还要归一化法线 12345v2f vert(input i ) &#123; …… o.normal = mul((float3x3)unity_ObjectToWorld, i.normal); o.normal = normalize(o.normal);&#125; 法线直接使用这个变量转换是错误的。因为在转换的时候会把物体的缩放也计算进去，导致法线变形。 缩放x轴，顶点和法线都一起缩放了1/2 正确的处理应该是法线要按相反方向缩放。 缩放x轴，顶点缩小，2法线放大2 对于绕z轴的旋转矩阵 因为 sin(-z)=-sinz cos(-z)=cosz $\\left|\\begin{array}{lcr}cosz&amp;-sinz&amp;0 \\sinz&amp;cosz&amp;0 \\0 &amp; 0 &amp; 1\\end{array}\\right|^{-1} = \\left|\\begin{array}{lcr}cosz&amp;sinz&amp;0 \\-sinz&amp;cosz&amp;0 \\0 &amp; 0 &amp; 1\\end{array}\\right|$ 所以 R^{-1} = R^{T}R 推导 我们希望改变缩放的方向为相反，但不改变旋转的转换 设变换矩阵为 O=S_1R_1P_1S_2R_2P_2S_3R_3P_3 把它缩短成 O=S_1R_1S_2R_2 因为缩放要取相反方向，例如缩放了 \\frac{1}{2} ，我们就要放大 \\frac{1}{2}^{-1}=2 ，即要取逆矩阵 所以我们希望得到变换矩阵是 N=S_1^{-1}R_1S_2^{-1}R_2 已知公式： (AB)^{-1}=B^{-1}A^{-1} (AB)^T=B^TA^T 对于旋转矩阵 R^{-1} = R^{T} 因为缩放矩阵是只有斜线有数值 S^{T} = S 那么： O^{-1}=R_2^{-1}S_2^{-1}R_1^{-1}S_1^{-1}=R_2^TS_2^{-1}R_1^TS_1^{-1} (O^{-1})^T=(S_1^{-1})^T(R_1^T)^T(S_2^{-1})^T(R_2^T)^T=(S_1^{-1})^TR_1(S_2^{-1})^TR_2 最终就是我们希望的矩阵： N=(O^{-1})^T=S_1^{-1}R_1S_2^{-1}R_2 所以我们使用对这个矩阵取逆后再转置才能得到正确的转换矩阵。 $$(O^{-1})^T=N$$ 12345v2f vert(input i ) &#123; …… o.normal = mul(transpose((float3x3)unity_WorldToObject),i.normal); o.normal = normalize(o.normal);&#125; 恰好UnityCG.cginc中包含了法线转换的函数UnityObjectToWorldNormal效率会更高一些。 12345v2f vert(input i ) &#123; …… o.normal = UnityObjectToWorldNormal(i.normal); i.normal = normalize(i.normal);&#125; 因为顶点着色器传递给片元着色器的时候会需要进行插值，所以我们可以选择在片元着色器里再一次对法线进行归一化，当然插值产生的误差通常很小，为了性能一般不作要求。 漫反射Diffuse物体本身不发光，全靠发射光来映入人脸。 光打到物体时候，部分直接反弹，部分穿透了表面经理多次和原子的碰撞后再反弹出来，部分会被吸收。 光照的经验模型。 Lambert漫反射的光量与光方向和表面法线之间的角度的余弦值成正比。 漫反射 我们使用一个固定的值模拟光源位置float3（0，1，0）模拟光源在头顶。 1234float4 frag( v2f i ) &#123; i.normal = normalize(i.normal); return dot (float3(0, 1, 0), i.normal);//使用点积&#125; 当夹角＞90°的时候，值是负数的，负数的光其实就是全黑，我们不需要负数的光 我们使用saturate函数把值规范在0~1之间，小于0的值之间舍弃。 1return saturate(dot(float3(0, 1, 0), i.normal)); 在UnityStandardBRDF.cginc中有一个方便的函数DotClamped我们使用它来替代 1234567//#include &quot;UnityCG.cginc&quot;#include &quot;UnityStandardBRDF.cginc&quot; ……float4 frag( v2f i ) &#123; i.normal = normalize(i.normal); return DotClamped(float3(0, 1, 0), i.normal);&#125; 因为UnityStandardBRDF.cginc已经包含了UnityCG.cginc所以我们可以把它去掉 文件包含层次结构 Unity光源在UnityShaderVariables定义float4 _WorldSpaceLightPos0变量，它代表了光源在世界空间下的位置。 我们可以使用它来作为光源位置 1float3 lightDir = _WorldSpaceLightPos0.xyz ; 使用灯光的时候，我们需要指定渲染路径 12345678Pass &#123; Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125; CGPROGRAM …… ENDCG&#125; 光源颜色 我们可以使用在UnityLightingCommon.cginc中定义的fixed4 _LightColor0获取光源颜色 1234567float4 frag (v2f i ) : SV_TARGET &#123; i.normal = normalize(i.normal); float3 lightDir = _WorldSpaceLightPos0.xyz; float3 lightColor = _LightColor0.rgb; float3 diffuse = lightColor * DotClamped(lightDir, i.normal); return float4(diffuse, 1);&#125; AlbedoDiffuse（漫反射）的颜色称为Albedo（反照率） 用贴图和Tint颜色来定义 12345678float4 frag (v2f i ) : SV_TARGET &#123;i.normal = normalize(i.normal); float3 lightDir = _WorldSpaceLightPos0.xyz; float3 lightColor = _LightColor0.rgb; float3 albedo = tex2D(_MainTex, i.uv).rgb * _Tint.rgb; float3 diffuse = albedo * lightColor * DotClamped(lightDir, i.normal); return float4(diffuse, 1);&#125; 高光Specular光打到物体后，直接反射到你眼睛的光量。 我们需要知道 观察者的方向，通过世界空间下相机和表面顶点的位置差求得 反射光方向 Blinn顶点在世界空间下的位置 123456789101112struct v2f &#123; …… float3 normal : TEXCOORD1; float3 worldPos : TEXCOORD2;&#125;v2f vert(input i ) &#123; v2f o; …… o.worldPos = mul(unity_ObjectToWorld, i.position);//顶点转换 o.normal = UnityObjectToWorldNormal(i.normal); o.normal = normalize(o.normal);&#125; 摄像机的位置可以通过UnityShaderVariables定义的float3 _WorldSpaceCameraPos获得 所以观察者方向就是： 1float3 viewDir = normalize(_WorldSpaceCameraPos - i.worldPos); 反射光方向 使用reflect函数计算，它是通过入射光方向和法线计算的，所以这里的lightDir要取反。 1float3 reflectionDir = reflect(-lightDir, i.normal); 在frag整合高光效果 1return DotClamped(viewDir, reflectionDir); Smoothness平滑度高光大小取决于材料的粗糙程度，光滑的材料高光应该较小。我们提供一个平滑值来调整高光的大小。通过幂函数的形式。 1return pow(DotClamped(viewDir, reflectionDir),_Smoothness * 100); 因为点积的值是0~1 幂大于1的，高光才会逐渐减少。 为了方便调整我们设置的平滑度范围是在0~1区间，这里乘100是为了放大这个数，使计算的高光表现出更好的效果。 Blinn-Phong上面是基于Blinn的高光经验模型， Unity Shader学习笔记：04-光照模型 使用光线方向和观察者方向之间的半角向量来确定高光范围。 123//float3 reflectionDir = reflect(-lightDir, i.normal);float3 halfVector = normalize(lightDir + viewDir);return pow(DotClamped(halfVector, i.normal),_Smoothness * 100); 高光更细腻 高光颜色给高光添加光源颜色 输出结果乘以lightColor即可。 我们还可以给高光另外添加颜色 1float3 specular = _SpecularTint.rgb * lightColor * pow(DotClamped(halfVector, i.normal),_Smoothness * 100); 能量的消耗漫反射和高光直接叠加后会出现过曝的效果。 那是因为当使用低Smoothness和白色的SpecularTint，高光部分的颜色值会大于1 ，可以理解为光的能量溢出了，不守恒。 光线打到物体上有一部分是要被吸收消耗掉的。 简单的使用1减去高光颜色的值来调整albedo 12float3 albedo = tex2D(_MainTex, i.uv).rgb * _Tint.rgb;albedo *= 1 - _SpecularTint.rgb; 但是这样调整会把三色通道分开减少了，从而导致了albedo颜色会出现错误 我们只需要SpecularTint单个通道的最大值来调整，这样albedo将会三个通道一起减少。 对于这种能量的调整，Unity在UnityStandardUtils.cginc中内置了方法 EnergyConservationBetweenDiffuseAndSpecular() 12float oneMinusReflectivity;albedo=EnergyConservationBetweenDiffuseAndSpecular(albedo,_SpecularTint.rgb, oneMinusReflectivity); oneMinusReflectivity是此方法中输出的一个值，这是一减去高光强度，表示高光反射率的albedo的因子。简单理解就是上面的1 - _SpecularTint.rgb 这个值输出出来是因为可以用在其他的光照计算中去。 文件结构 金属工作流我们主要模拟的是金属和非金属 金属没有反照率（albedo）可以使用该颜色数据作为高光的反射颜色。 非金属没有高光的反射颜色 所以我们不需要设置单独的高光颜色，就是不需要手动调色的那种Tint 使用0~1范围的_Metallic值来模拟金属度 1234567float3 specularTint = albedo * _Metallic;float oneMinusReflectivity = 1 - _Metallic;//albedo = EnergyConservationBetweenDiffuseAndSpecular(albedo,_SpecularTint.rgb, oneMinusReflectivity);albedo *= oneMinusReflectivity;float3 diffuse =albedo * lightColor * DotClamped(lightDir, i.normal);float3 halfVector = normalize(lightDir + viewDir);float3 specular = specularTint * lightColor * pow(DotClamped(halfVector, i.normal),_Smoothness * 100); 但是这过于简单，Metallic=0的时候会完全没有高光反射，但这是不符合现时的。 就算是纯的非金属，也会需要一些高光。 Unity在UnityStandardUtils.cginc中内置了方法DiffuseAndSpecularFromMetallic 1234float3 specularTint; // = albedo * _Metallic;float oneMinusReflectivity; // = 1 - _Metallic;//albedo *= oneMinusReflectivity;albedo = DiffuseAndSpecularFromMetallic(albedo, _Metallic, specularTint, oneMinusReflectivity); 金属度应该位于伽马空间，线性空间下，单个值unity不会自动进行伽马校正。 1[Gamma] _Metallic (&quot;Metallic&quot;, Range(0, 1)) = 0 Unity的PBSBlinn-Phong这些只是经验模型 PBR基于物理的渲染 PBR算法比较复杂，这里先看看如何调用unity内置的PBS算法。 在UnityPBSLighting.cginc中包含了UNITY_BRDF_PBS方法 123// #include“ UnityStandardBRDF.cginc”// #include“ UnityStandardUtils.cginc”#include“ UnityPBSLighting.cginc” Unity为不同平台定制了不同的BRDF函数，3.0以上会使用最佳的函数。 123CGPROGRAM#pragma target 3.0 //指定这个shader级别#pragma vertex vert 可以在frag中直接输出 1return UNITY_BRDF_PBS();//这里有八个参数需要输入 前两个是材质的漫反射和高光颜色 之后是反射率和粗糙度；这两个值必须是一减的形式。Smoothness=1-Roughness. 然后是法线，观察方向 最后是直接光和间接光的两个结构体 1return UNITY_BRDF_PBS(albedo, specularTint, oneMinusReflectivity, _Smoothness, i.normal, viewDir)； UnityLightingCommon定义了一个简单的UnityLight结构体，它包括灯光颜色，灯光方向和NdotL的值 1234UnityLight light;light.color = lightColor;light.dir = lightDir;light.ndotl = DotClamped(i.normal, lightDir); 间接光也有一个结构体UnityIndirect，它包括diffuse表示环境光，specular表示环境光反射。这里我们都先设置为黑色。 123UnityIndirect indirectLight;indirectLight.diffuse = 0;indirectLight.specular = 0; frag完整代码 1234567891011121314151617181920212223242526272829303132float4 frag (v2f i) : SV_TARGET &#123; //albedo i.normal = normalize(i.normal); float3 lightDir = _WorldSpaceLightPos0.xyz; float3 viewDir = normalize(_WorldSpaceCameraPos - i.worldPos); float3 lightColor = _LightColor0.rgb; float3 albedo = tex2D(_MainTex, i.uv).rgb * _Tint.rgb; //specular float3 specularTint; float oneMinusReflectivity; albedo = DiffuseAndSpecularFromMetallic(albedo, _Metallic, specularTint, oneMinusReflectivity); //两个结构体 UnityLight light; light.color = lightColor; light.dir = lightDir; light.ndotl = DotClamped(i.normal, lightDir); UnityIndirect indirectLight; indirectLight.diffuse = 0; indirectLight.specular = 0; //Unity内置pbs函数 return UNITY_BRDF_PBS( albedo, specularTint, oneMinusReflectivity, _Smoothness, i.normal, viewDir, light, indirectLight);&#125; 参考像猫一样编程~04 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础 Unity Shader学习笔记：03-纹理混合 Unity Shader学习笔记：04-光照模型","permalink":"https://ppuyan.github.io/2021/01/note_shader_04.illumination-model/","photos":[]},{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：03-纹理混合","date":"2021/01/15","text":"利用mipmap，制作细节贴图 Detail Texture纹素是固定的，意味着即使2k图片，放大图像也将会变得很模糊 需要引入细节贴图 两张贴图混合这里使用两张贴图混合来模拟细节贴图 使用灰度图作为细节贴图。 原始贴图和灰度图 使用这两张贴图是因为可以明显的看出效果。 处理两张贴图 1234Properties &#123; _MainTex(“Texture”,2D)=”white”&#123;&#125; _DetailTex(“DetailTexture”,2D)=”gray”&#123;&#125;//灰色值是（0.5，0.5，0.5）&#125; 为第二张贴图添加独立的uv 123456789struct Input &#123; float2 uv : TEXCOORD0; float2 uvDetail : TEXCOORD1;&#125;struct v2f &#123; float2 uv : TEXCOORD0; float2 uvDetail : TEXCOORD1;&#125; 同样的声明变量，然后在vert函数中与第一张贴图类似，这里省略 12345float4 frag (v2f i ) : SV_TARGET &#123; float4 color = tex2D(_MainTex, i.uv) * _Tint; color *= tex2D(_DetailTex, i.uvDetail) * 2;//这里为什么要乘2呢↓ return color;&#125; 把第二张贴图Tilling增大 这里为什么要乘2？ 我们要使两张贴图混合的时候，可以把两张图的颜色值乘起来。 但是我们知道颜色值是0~1区间的，所以当两张图的颜色值相乘的时候，数值会变小，颜色会变暗。 这里乘以2就是为了放大数值，这样作为细节贴图的时候，0~0.5的颜色会让原始贴图变暗，0.5~1的颜色会让原始贴图变亮。这就是为什么使用gray值和灰度图来处理细节贴图。 如果不使用灰度图，而使用原图直接乘2的话，可以看到颜色都会很亮，因为所有值都被放大了两倍。 直接乘2 使用灰度图乘2 使用灰度图可以看到明显的明暗变化。 远近渐变使用细节贴图就是为了能在近距离观察的时候能够呈现更好的细节 但是远距离观看的时候是不必要的，这样会能看到很明显的Tilling效果 我们可以使用在远距离淡化图片为灰色的技巧，因为灰色不会引起颜色变化 因为（0.5，0.5，0.5）*2=（1，1，1）是白色 在使用的Detail Texture的贴图设置中启用Fadeout Mip Maps 可以看到在远处不产生细节效果 实际运用效果因为我们使用了能看到明显效果的贴图才能看到有明显颜色渐变 当使用常规贴图的时候 大理石纹理 可以看到有无细节贴图的差别。 色彩空间伽马空间对光强度的调整 早期的显示器为非线性的特性，因为眼睛对不同光强度的敏感问题。 颜色在较暗之间的变化大于较亮之间的变化。 使用指数运算来区别明暗的压缩和拉伸范围。亮处压缩，暗处拉伸 sRGB存储的是平均伽马值为1/2.2的颜色，所以使用2.2的伽马校正。 线性色彩空间优点之一：实现更逼真的光照计算，因为现实中就是线性变化的，不是指数变化的。 在Unity中使用伽马空间会直接访问原始的sRGB颜色和纹理数据 但我们在Unity使用线性空间的时候，会先将这些数据转换到线性空间进行操作，再传回伽马空间。 我们在颜色乘2的时候之前，在0.5附近的地方伽马校正后是0.5^2.2 ≈ 0.22，两倍就是0.44远小于1，所以颜色会变暗。在线性空间下应该要纠正为1/0.5^2.2 ≈ 4.59. UnityCG.cginc中提供了这样一个变量，unity_ColorSpaceDouble，我们使用它来取代之前的2倍。这个float4的值在rgb中是2或者4.59，但在a中是2。因为伽马校正不会作用与Alpha通道。 1color *= tex2D(_DetailTex, i.uvDetail) * unity_ColorSpaceDouble; 贴图的Splatting用于地形贴图。地形通常包括草，沙石，雪等。 使用0~1区间作为两张贴图的线性插值，使之混合。 我们再添加1张贴图用作Splatting 注意导入贴图的设置 绕过sRGB进行采样，这样就会无论在哪个色彩空间都是直接获取图片数据。 在线性空间下生成mipmap。 Splat贴图不应该进行Tilling所以设置成clamp模式。 添加Properties，这里省略。 通常地形的贴图Tilling值都是相同的，而Splat贴图不需要Tiling变化。 这里有个trick 我们使用一个uv通道来表示地形纹理的Tilling，上图中splat贴图的Tilling和Offset实际是运用到下面的两张地形贴图中的。 在面板中不显示Tilling和Offset可以添加字段**[ NoScaleOffset ]**来隐藏 12[ NoScaleOffset ]_Texture1（“ Texture 1”，2D）= “ white” &#123;&#125;[ NoScaleOffset ]_Texture2（“ Texture 2”，2D）= “ white” &#123;&#125; 准备工作完成，我们开始使用Splat贴图 对Splat贴图采样 1float4 splat = tex2D(_MainTex, i.uvSplat);//此时的uvSplat是直接传递物体uv的。 使用插值对两张图进行混合。 1return tex2D(_Texture1, i.uv) * splat.r +tex2D(_Texture2, i.uv) * (1 - splat.r); RGB 的Splat贴图单通道下实现两张贴图的混合，那么在RGB三个通道下可以使用四张贴图混合。第四张只需要1-r-g-b即可。需要规范的是，rgb三色加起来要＜=1； 12345return tex2D(_Texture1, i.uv) * splat.r + tex2D(_Texture2, i.uv) * splat.g + tex2D(_Texture3, i.uv) * splat.b + tex2D(_Texture4, i.uv) * (1 - splat.r - splat.g - splat.b); 参考像猫一样编程~03 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础 Unity Shader学习笔记：03-纹理混合 Unity Shader学习笔记：04-光照模型","permalink":"https://ppuyan.github.io/2021/01/note_shader_03.mix-textures/","photos":[]},{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：02-着色器基础","date":"2021/01/15","text":"Unity shaderlab的基础知识 物体到图像Mesh renderer组件 Unity检查对象的边界框判断物体部分或全部是否在摄像机视锥体内。 Transform 组件 各自负责什么 第一个shader创建Unlit Shader，并以此创建新材质 Shader编译Unity Shader编译器会将代码转换成不同的平台代码。例如D3D、OpenGL等。 可以通过Compiled code查看编译平台和编译后的代码。 Shader结构1234567891011121314151617181920212223242526Shader “Custom/First Shader” &#123; Properties &#123; ///TODO &#125; SubShader &#123; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc” struct input &#123; ///TODO &#125; struct v2f &#123; ///TODO &#125; v2f vert (input i ) : SV_POSITION &#123; ///TODO &#125; float4 frag (v2f i ) : SV_TARGET &#123; ///TODO &#125; ENDCG &#125; &#125;&#125; SubShade可以用于构建不同平台或实现不同的细节程度（LOD） Properties我们可以添加自己定义的变量属性并显示到Unity面板上。此时并没有声明变量，只是出现在了Unity面板上。 一般的变量名以下划线开头。 定义Unity面板上的名字 定义数据类型 赋予初始值 123Properties &#123; _Tint(“main Color”，Color) = (1，1，1，1)&#125; Pass我们在Pass中编写shader代码。 shader 语言目前有三种，HLSL（DirectX）、GLSL（OpenGL）、Cg（NVIDIA和微软协作） Unity Shader是HLSL和Cg语言的变体。 以CGPROGRAM和ENDCG包围代码 12345Pass &#123; CGPROGRAM ///TODO ENDCG&#125; 编译指令#pragma指示哪些程序使用哪些函数。 1234CGPROGRAM #pragma vertex vert //告诉顶点着色器使用vert这个函数 #pragma fragment fragENDCG 引用文件#include一整套完整的shader需要大量的样板代码。定义公用变量，函数和其他内容。类似其他高级语言中的类。 Shader没有类，可以分成多个文件，使用**#include**加载 Unity为我们准备了UnityCG.cginc。 123456CGPROGRAM #pragma vertex vert #pragma fragment frag #include “UnityCG.cginc”ENDCG 层次结构 声明变量我们要使用Properties中自定义的变量时，我们首先需要声明它。 在Pass中声明 12345678Pass &#123; CGPROGRAM #pragma #include float4 _Tint; …… ENDCG&#125; 顶点着色器和片元着色器 顶点着色器输出处理后的顶点数据 之后进入光栅化阶段，进行三角形处理：以处理的三个顶点之间进行插值计算 传递插值数据到片元着色器 数据的传递和语义渲染东西时，我们要输入一些数据，处理后，再输出一些数据。 输入： 我们将模型的顶点数据输入到vert顶点着色器中 使用语义POSITION，指的就是物体在模型空间下的顶点数据 123void vert (float4 position : POSITION) &#123; ///TODO&#125; 输出： 在前面的vert顶点函数中，我们要返回处理后的顶点坐标。坐标空间是四维的齐次坐标，使用4x4矩阵。 同样的frag片元函数中，我们要输出颜色值。 同时使用SV_POSITION语义来规范输出。 SV指的是Systems Value（系统值） SV_POSITION指的是用于标识经过坐标变换后的顶点坐标。 SV_TARGET指的是片元着色器的颜色输出语义 123456float4 vert (float4 position : POSITION) : SV_POSITION &#123; return 0;&#125;float4 frag (float4 position : POSITION) : SV_TARGET &#123; return position;&#125; 这里我们尝试输出一个物体本地坐标的颜色，因为线性插值的关系，所以会有颜色的过度 通常x方向为红色，y方向为绿色，z方向为蓝色。 1234567891011float4 vert(float4 position:POSITION,out float3 localPotition: TEXCOORD0) : SV_POSITION&#123; localPosition=position.xyz;//模型空间坐标 return mul(UNITY_MATRIX_MVP, position);//顶点坐标的转换&#125;float4 frag (float4 position:SV_POSITION,float3 localPosition : TEXCOORD0):SV_TARGET &#123; return float4 (localPosition,1);&#125; TEXCOORD0语义一般指顶点的第一套纹理坐标 这里并没有使用纹理的意思，使用TEXCOORD0语义，可以就当作占个坑，用这个坑过度一下处理数据这样。 颜色调整颜色的值应该在0~1之间。 而默认的球体半径是0.5的，所以在模型空间中它的值应该是-0.5~0.5 这就导致0以下的数值会被舍弃掉，所以我们把他规范到0~1中 1return float4 (localPosition+0.5, 1); 使用结构体为了代码的整洁，我们可以使用结构体作为输入和输出。 12345678910111213141516Pass &#123; CGPROGRAM …… struct Input &#123; float4 position : POSITION; float3 localPosition : TEXCOORD0; &#125; struct v2f &#123; float4 position : SV_POSITION;//这里直接使用语义就可以省下顶点着色器的输出语义 float3 localPosition : TEXCOORD0; &#125; …… ENDCG&#125; 整合上面的代码 123456789101112131415161718Pass &#123; CGPROGRAM …… v2f vert (Input i ) &#123; v2f o; i.localPosition=o.position.xyz;//模型空间坐标 mul(UNITY_MATRIX_MVP, position);//顶点坐标的转换 return o; &#125; float4 frag (v2f i ) : SV_TARGET &#123; return float4 (i.localPosition,1); &#125; ENDCG&#125; 贴图贴图采用UV二维坐标 左下角（0，0）右上角（1，1） OpenGL由下到上 | D3D由上到下 添加贴图添加Properties 123Properties &#123; _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;&#125; 声明变量 123float4 _Tint;sampler2D _MainTex;float4 _MainTex_ST;//用于Tilling And Offset 数据输入和输出的结构体 12345678struct input &#123; float4 position : POSITION; float2 uv : TEXCOORD0;&#125;struct v2f &#123; float4 position : SV_POSITION; float2 uv : TEXCOORD0;&#125; 在vert函数中我们直接返回uv值 123456v2f vert(input i )&#123; …… mul(UNITY_MATRIX_MVP, position); o.uv=i.uv; ……&#125; 然后在frag函数中用tex2D进行采样 123float4 frag (v2f i ) : SV_TARGET &#123; return tex2D(_MainTex, i.uv);&#125; 发生纹理变形是因为插值在三角形之间是线性的。Unity球体在极点附近只有几个三角形，其中UV坐标变形最大。因此，UV坐标在各个顶点之间非线性地变化，但是在顶点之间，它们的变化是线性的。所以，纹理中的直线突然在三角形边界处改变方向。 平铺和偏移就是使用之前添加的_MainTex_ST 1i.uv = v.uv * _MainTex_ST.xy + _MainTex_ST.zw; 通常我们使用在UnityCG.cginc中定义好的函数进行这个操作 1i.uv = TRANSFORM_TEX(v.uv, _MainTex)； Unity中的图片设置 Wrap Mode： Clamp：图片被限制在0~1之间 Repeat：在超过1之后的地方会进行repeat 言简意赅，图片在Tilling改变后是否会被拉伸。 在0-1范围内，两者在图像边缘的处理上会存在差别 Repeat的时候，如果边缘两处颜色不相似，边缘处会渗出一点点另一边的颜色。 Clamp的时候边缘并不明显。 Filter Mode： img 主要解决纹素投影到像素不完全匹配的问题。 因为采样的问题，单个像素出现的纹素过多的时候，两个像素间采样的值将会超过一个纹素样本 Point（不过滤）采样的时候取最近的纹素，会产生块状外观 默认为Bilinear（双线性）在两个纹素间的某个位置进行采样，将这两个纹素进行插值。 启用Mipmap，默认是启用的使用不同层级的贴图，例如原贴图512x512那么其mipmap就是256x256,128x128等 使用原理就是，当单个像素内，纹素密度过高的时候，使用较小的mipmap，来降低纹素密度。 有mipmap 无mipmap 各向异性过滤当角度过于平的时候，会出现远处很模糊，这是因为远处纹素密度过大，使用了较低的mipmap所以会很模糊。 在两个维度上缩放不同数量，所以是各向异性。例如除了256x256的mipmap还有256x128、256x64等的mipmap。 无各向异性滤波 有各向异性滤波 这些额外的Mipmap不会像常规的Mipmap预先生成，采样时进行额外的模拟。 不需要额外的空间，但采样成本变高。 参考像猫一样编程~02 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础 Unity Shader学习笔记：03-纹理混合 Unity Shader学习笔记：04-光照模型","permalink":"https://ppuyan.github.io/2021/01/note_shader_02.shader-fundamentals/","photos":[]},{"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"}],"title":"Unity Shader学习笔记：01-渲染管线","date":"2021/01/15","text":"简单的概述渲染管线~ GPU or CPU？刷新率（fps）会影响游戏体验。正常30Hz；流畅60Hz；VR双目常态90Hz； 以iPhone Xs Max来说，一个游戏如果要达到每秒30帧，需要多少计算呢？数量级能达到十亿、百亿。（[分辨率] 2688 * 1242 * [帧率] 30 * [填充率（平均最小3）] n * [单像素计算步骤数] m） CPU善于处理单一复杂运算，GPU处理较大的数量级运算（并行计算，速度更快） GPU原理GPU发展趋势：可配置固定管线 \\rightarrow 可自定义算法的编程模块 GPU硬件结构 数据并行结构GPU是流处理器，内有成千上万小型处理器——shader运算核。 同时处理大量相似数据 相互独立不用访问相邻核心 少了很多用于逻辑运算和缓存 SIMD（单指令多数据） 访问数据的延迟远远大于运算的延迟，采用分离运算和数据的设计减少延迟。 即先按顺序完成所有像素的运算指令，再返回去执行访问指令。 单指令多数据 每个像素的shader调用被称为一个线程，与CPU线程不同，GPU线程会带有一点输入内存和运行寄存器。使用相同shader的线程可以组合成线程束。 例如英伟达GPU的线程束可包含32个线程，那要计算2000个像素就需要2000 / 32 = 63（向上取整）个线程束。第一个线程束停滞处理问题时，第二个开始运行，以此类推，最后一个线程束停滞时再回到第一个线程束。 渲染管线（流水线） 四个大阶段：应用阶段、几何运算、光栅化、像素运算 应用阶段一般由CPU执行; 包括用户输入处理、碰撞检测、动画、物理模拟、全局加速算法等; 基于CPU，开发者有绝对控制权; 可通过Compute Shader 交给GPU来做，将GPU当做一个高并行的普通处理器来使用; 输出渲染数据到下一阶段：几何元素（点、线、三角面）、纹理、参数等。 几何运算细分为四个子阶段：顶点Shading阶段、投影阶段、剪裁阶段、屏幕映射阶段。 顶点着色器阶段（可直接编程，vertex shader）计算顶点位置，输出法线，纹理坐标等顶点相关信息 可用来处理顶点动画，修改法线方向 模型空间到世界空间，世界空间到相机空间，再投影、剪裁，最后变换为单位立方体 空间变换： Object \\Rightarrow World 模型-世界 World \\Rightarrow Camera 世界-相机 Camera \\Rightarrow clip 相机-裁剪（投影变换） Tangent \\Rightarrow World （法线贴图） World \\Rightarrow Tangent（视差贴图） 投影后，模型所在空间为裁剪空间。 三维空间 \\Rightarrow 另一个三维空间 Z坐标存在Z-buff中 最终模型从三维投影到二维平面。 顶点着色阶段前也有一些数据操作，在DirectX中称为输入整合器，将流数据编为集合传入管线。其可以根据顶点和颜色数组生成物体三角面。 GPU instancing是通过输入整合器实现的。允许一个物体通过变化数据完成多次绘制，但只占用一个Draw Call。 可选顶点过程部分GPU支持此阶段：细分曲面，几何着色和流输出。 细分曲面：原有几何体上增加顶点和三角面。对比CPU，GPU增加顶点的开销不大。 几何着色：也能产生新顶点和三角面，但不一定要在原有图素上。可用于粒子的生成、草原、毛发等。 流输出：将GPU当几何处理器，处理后的信息存在数组，后续交由CPU或GPU操作。 裁剪部分在视觉空间里的图素需要裁剪。 裁剪阶段使用四维齐次坐标。因为透视投影后，三角面无法使用线性插值，第四个数值的作用就是为了能正常插值。（透视修正插值） 屏幕映射裁剪后以三维坐标传入，称为窗口坐标。 窗口坐标缩放到屏幕像素，称为屏幕坐标，z值映射到0~1 光栅化三角面输入，找到三角面内所有像素。 子阶段：三角面设置，三角面遍历 三角面设置阶段：会计算三角面的微分方程、边的等式和其他数据，这些数据用于三角形遍历以及一些几何阶段产生的Shading数据的插值。 三角形遍历：会判断三角形与像素（采样点）的交叠并生产片元，片元内包含了三个顶点间的插值数据（包含深度）。 像素运算此阶段逐像素操作，每个图素内的像素（而不是屏幕内的像素）都会使用一段程序来确定是否可见（如深度测试）和其颜色。 子阶段：像素Shading，合并阶段 像素/片元着色器（可编程，fragment shader）输入：插值后的Shading数据， 输出到合并阶段：一种或多种颜色。 片元：三角面全部或部分覆盖单个像素的部分。 此阶段可以丢弃一些片元 合并阶段混合颜色缓冲 z-buff（深度缓冲）à决定可见性。渲染图素时，同一像素内，z值与z缓冲值比较，z值更小会被渲染，更新z缓冲和颜色缓冲；z值更大则无变化。 传统z-buff缺点：只存储一个深度，无法用于半透明。半透明后于不透明物体绘制。 early-z/pre-z：在像素shading前进行深度测试。但是像素阶段可以改变深度或者抛弃片元（Alpha Cutoff），这会导致Early-Z失效。 模板缓冲：用于记录一些图素的位置，图素可以用多种方式写入模板缓冲，此缓冲可用于控制是否写入颜色缓冲与深度缓冲。用这样的方法我们能实现一些有趣的效果，例如只有通过特殊镜片才能看到的文字等等。 模板测试实现非欧几何 最后合并颜色，当前图素颜色与缓冲颜色进行合并，半透或叠加。 参考https://zhuanlan.zhihu.com/p/336999443 TocUnity Shader学习笔记：01-渲染管线 Unity Shader学习笔记：02-着色器基础 Unity Shader学习笔记：03-纹理混合 Unity Shader学习笔记：04-光照模型","permalink":"https://ppuyan.github.io/2021/01/note_shader_01.render-pipline/","photos":[]},{"tags":[{"name":"Substance Painter","slug":"Substance-Painter","permalink":"https://ppuyan.github.io/tags/Substance-Painter/"}],"title":"Substance Painter入门教程笔记：煤油灯","date":"2020/12/10","text":"初次接触Substance Painter！ 前言​ 初次接触Substance Painter，主要为了熟悉SP界面和工作流程。本文并非教程，只是记录学习轨迹，所以开门见山地贴出教程地址，有兴趣可以前往学习。 教程地址： 官网：SUBSTANCE PAINTER 2018 初学者B站：Substance Painter 入门教程：煤油灯 正文快捷键视图旋转：alt+左键 视图缩放：alt+右键 视图平移：alt+中键 旋转环境光贴图：shift+右键 在模型上选择Texture set（材质）：ctrl+alt+右键 循环贴图显示模式：shift+B 返回材质模式：M 循环通道显示：C 笔刷大小：ctrl+右键左右移动 笔刷alpha硬度值：ctrl+右键上下移动 笔刷流量：ctrl+左键左右移动 阻止画刷叠加构建：A 旋转笔刷alpha贴图：ctrl+左键上下移动 画直线：左键+shift 直线按15°刻度吸附：shift+ctrl+左键 Stencil模板：s+右键缩放，s+左键旋转，s+中键移动 笔刷黑白切换：x 要点Texture set = material ID在SP中Texture set（纹理设置）是三维软件中设置的Material ID（材质ID） Texture set=Material ID 导入外部贴图Shelf -&gt; importing resources 为导入的资源创建关键字或标签。 图层文件夹和智能材质使用图层文件夹方便管理材质。 右键这个文件夹可以创建智能材质，创建智能材质会自动存储烘焙好的贴图，方便下次使用的时候自动设置。 同样的也可以创建智能遮罩。 图层覆盖上面图层覆盖下面图层的效果，比如Height 在第一个层中Height值为0，但是下面的图层中存在高度值，并仍然显示。 切换图层中的显示模式BaseColor为Height模式，可以看到默认的混合模式为线性添加，意味这所以图层高度值是叠加的。 如果要当前图层覆盖下面所有图层，将混合模式设置为normal标准 流程创建透明材质创建新shader并增加不透明度（opacity） PS：2020新版SP创建shader被放置在纹理设置里 设置Shader：pbr-metal-rough-with-alpha-blending 新建填充层，并设置透明度（右键视图窗口快捷调出属性面板） 烘焙贴图选择Texture set list里的base1打开纹理设置进行烘焙 教程中直接使用高模制作贴图，所以不用烘焙法线贴图和厚度贴图。在ID选项中把Color Source的Vertex Color改为Material Color。（新版默认是材质颜色）在高模选项中选择lantern_id,为了烘焙ID贴图，教程中弄了一个一样的模型，但是在模型的不同材质间赋予了不同颜色。 重新烘焙ID贴图烘焙的时候造成投射错误，会让后续使用ID贴图制作mask的时候存在错误。所以应该在烘焙的时候炸开（分离）模型。 在烘焙设置的Match选择中选择by mesh name，在下面的选项中更改高低模型对应的后缀，例如教程里的_id、_main。通过组名称来分离模型，SP在计算光线追踪的时候就会单独计算名字相匹配的模型。 创建基础材质颜色基础层选择Texture set list=&gt;base1 新建图层base调节颜色 粗糙度层新建图层rough并添加黑色遮罩，关闭除rough以外的通道 在遮罩下添加Generator生成器dirt（根据之前烘焙的贴图程序化的生成污渍mask） 解决UV接缝，打开生成器里的Triplannar（三面投射）*后续使用到新的图层或填充也要开启三面投射* 在rough-&gt;mask下再新建一层并填充特效（图层-添加特效-添加填充）。在Grayscale添加Grunge Paint Scratch灰度图 改变Grunge Paint Scratch混合模式为Lighten（max） 实现效果： 油迹斑点层新建图层paint specks并添加黑色遮罩，关闭除height以外的通道，设置Height值为正数。 与rough类似，在mask上添加填充特效。 同样的为了避免UV接缝，打开三面投射。 在mask的填充中添加灰度图BnW Spots 1，适当调节参数 实现效果： 边缘暗淡新建图层，添加黑色遮罩，添加Mask Editor生成器，调节curvature曲率的参数 在mask上再添加新的填充特效。使用Grunge Rust Fine灰度图。并改变混合模式为Multip 实现效果：可以看到边缘有一些暗淡和无序的脏迹的效果。 再做一层变化复制上一层图层。更换新的填充特效。使用Grunge concrete old灰度图。调节层的颜色，复制多一层是为了使用不同的颜色，增加细微变化。 改变整个图层的混合模式为Overlay叠加，并降低透明度 实现效果： 第三层颜色变化添加黑色遮罩，添加填充特效，添加Light生成器。 添加一层填充特效，通过脏迹图来调节light生成器。添加Grunge concrete old灰度图，改变混合模式为Multiply 适当调节颜色，并更改图层混合模式为Value 添加生成器Dirt，借助生成器Dirt让高光颜色更集中。改变混合模式为Multiply 实现效果： 铁锈材质创建新图层base打开color，height，rough，ao通道。默认没有ao通道需要通过texture set设置面板里面添加。为各自通道添加导入的rust贴图。调节高度值 为材质创建遮罩创建图层文件夹，把上面的base图层放入其中。右键文件夹创建黑色遮罩层。 创建填充特效，选择Grunge 004作为灰度图 在这里我们不使用三面投射的方式，因为这个方式会出现一些映射模糊，直接使用UV投射。 创建填充特效，选择Grunge concrete old作为灰度图，设置三面映射。更改混合模式为Lighten（max） 创建Light生成器（分离铁锈积聚的地方）改变混合模式为Multiply，只在斜面上出现铁锈。 创建Dirt生成器，混合模式为Lighten（max） 创建Mask Editor生成器，主要为了把铁锈集中在边缘。 为Mask Editor增加第一张贴图：Grunge concrete old灰度图控制，并使用Multiply混合模式。 增加第二张贴图：Grunge scratch rough，并使用Lighten（max）混合模式，这张贴图主要增加划痕效果 最后把Mask Editor改为Lighten（max）混合模式 最后效果： 为铁锈颜色添加滤镜主要是更改铁锈颜色 智能材质的应用和图层链接智能材质可以直接拖拽到新的Texture set上，会自动设置对应烘焙好的贴图。更新其中一个Texture set的设置，另一个不会跟着变化。 图层链接 笔刷系统笔刷大小，笔刷流量，笔刷透明度，笔刷抖动，shelf中的笔刷预设，延迟笔刷，路径笔刷 保存笔刷预设：在绘画模式下属性面板中右键可以保存预设 tool工具预设会同时保存笔刷和材质 material材质预设只会保存材质 brush笔刷预设只会保存笔刷 绘画校准 分别是：镜头|wrap包裹|平面下的效果 在UV模式下不会画出uv边界，都适用于3d/2d窗口 Stencil模板：可以绘制图案。 纹理映射模式类似上面的stencil，不同在于有完整的材质属性，可以跨多个通道进行映射而不是一个灰色通道。 类似stencil的快捷键，同样使用s+鼠标键进行操作。使用的时候新建绘画图层，切换到映射模式，设置好需要映射的贴图即可开始绘制。 可以在显示设置里设置模板透明度。绘制的贴图颜色同样可以在层里面添加HSL滤镜进行调色 克隆工具特使的混合模式，要使用克隆工具要先新建绘画图层，并且把需要进行克隆的通道图层混合模式设置成passthrough穿过，例如basecolor，height，ao等通道信息都设置成passthrough穿过 克隆模式是非破坏性的，更改克隆图层下面的图层属性后，克隆的东西也会随着更新，就是passthrough模式的作用 克隆类似PS里面的印章。按住V键设置克隆源，就可以开始绘制。 锚定点系统文字细节更改笔刷的alpha贴图就可以印刷文字。 增加文字的AO，通过增加滤镜HBAO达到效果。 为文字增加铁锈影响使用锚定点。锚定点可以用来链接图层堆叠里的其中一个数据到另一个地方。 为我们上面的文字图层增加锚定点。右键-&gt;添加锚定点 打开rust-&gt;mg_dirt下面的MicroHeight选择anchor points指定刚刚文字图层里面的锚定点。设置引用通道为Height 然后进入微细节调节数值。 金属材质创建新的填充图层，使AO，高度信息覆盖下面图层。 设置金属值为1 添加Grunge rough dirty为Roughness贴图，设置三面映射。 使用色阶调整roughness贴图： 为图层增加levels特效，选择roughness通道作为受影响通道 边缘遮罩复制上述图层，并调整更亮的颜色，使用遮罩，让这个更亮的颜色集中在边缘位置。 添加黑色遮罩。添加Mask Editor生成器。 为Mask Editor添加纹理Grunge Dirt Scratched，记得把Texture值拉到1，不然会不起作用。 更改上述贴图的混合模式为Max（Lighen） 使用层文件管理金属材质的时候，别忘了要把文件夹的AO和高度信息覆盖下面图层。 使用ID贴图制作遮罩为metal rough这个材质文件夹添加颜色选择遮罩，这里就要使用到上面步骤中烘焙到的ID贴图。 选取ID颜色，指定金属部位。同时为了使金属部分也有铁锈，要把rust材质文件夹移动到最上层。 当初在制作rust材质的时候，没有使用金属通道，会导致铁锈部分看起来会太暗。 从金属通道可以看出来，metal rough占据了整个金属通道，而铁锈部分没有产生作用，这是不对的。我们把rust的金属通道打开，这时显示正确。 灯芯材质选择Texteure set-&gt;glass_enclosure 创建新的填充图层，类似的，我们使用层文件夹的形式创建遮罩。 这里我们使用新的遮罩方式。 为这个文件夹创建黑色遮罩，添加绘图特效。 使用几何填充工具。 在知道模型是分离的情况下可以使用模型填充，或者UV是分离的情况下也可以选择UV填充模式 把这个wick材质的AO，高度信息覆盖下面图层。 为这个base的高度通道，添加Fabric Alternate V贴图。并调整平铺值和UV比例值大小。 添加HBAO滤镜。 为这个base的basecolor通道添加Gradient Linear 1贴图 增加Gradient滤镜。调整灯芯的渐变颜色，适当的可以用使用paint特效，使用笔刷画，增加不规则感。 污垢材质使用同样的方法，选择Texture set-&gt; base1 创建层文件夹，Height和AO通道下设置normal标准混合模式。 创建填充图层，并添加黑色遮罩。 添加dirt生成器 添加填充特效，添加grunge concrete old作为灰度图，设置三面映射，Multiply混合模式 污垢自上而下复制上面的图层，删除填充图层，改变生成器为Mask Editor 这次我们关闭curvature，打开position gradien方位渐变，调节参数，使得污垢自上而下。 为这个生成器添加grunge concrete old贴图，并设置Multiply混合模式，主要为了打散污垢。 调节方位渐变，使得污垢自上往下。 玻璃材质玻璃材质主要是制作Roughness贴图。通过叠加多张sp自带的程序化贴图来使粗糙度有更多的变化。 选择Texture -&gt; glass1 添加新的填充图层命名为Glass关闭除Color，rough，opacity外的通道 填加新的填充图层，添加黑色遮罩 添加填充特效，加入Grunge rough dirty贴图。添加色阶特效 添加填充特效，加入Grunge stains small hollow贴图，Lighten（max）混合模式 添加填充特效，加入Grunge leaks贴图，Multiply混合模式 调整这些贴图的平衡到适合的值。 最后把Glass中的颜色值调接近白色 在渲染前先完善玻璃材质。为上面的玻璃添加之前创建好的dirt智能材质。 渲染进入玻璃的Texture set-&gt;glass1 打开顶部的Iray，进入着色器选项 把折射拖到1 进入显示设置可以调整背景，镜头，后处理等信息。 在上面的Iray设置中可以调整渲染时间，采样率等。 最终渲染效果： 导出贴图SP中有预设好的很多渲染器和引擎的贴图模板配置。当然也可以手动添加模板。","permalink":"https://ppuyan.github.io/2020/12/note_sp_start-with-lantern/","photos":[]},{"tags":[],"title":"Test","date":"2020/12/02","text":"Test TestTestTestTestTestTest123&lt;p&gt;code test&lt;/p&gt;&lt;div&gt;code test&lt;/div&gt;&lt;div&gt;long code test-----------------------------------------------------long code test&lt;/div&gt; 展开查看 System.out.println(\"Hello to see U!\"); 数学公式 数学公式 (O^{-1})^T=N `123`142","permalink":"https://ppuyan.github.io/2020/12/Test/","photos":[]}],"categories":[],"tags":[{"name":"shader","slug":"shader","permalink":"https://ppuyan.github.io/tags/shader/"},{"name":"unity","slug":"unity","permalink":"https://ppuyan.github.io/tags/unity/"},{"name":"Substance Painter","slug":"Substance-Painter","permalink":"https://ppuyan.github.io/tags/Substance-Painter/"}]}